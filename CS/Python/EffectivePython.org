#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+OPTIONS: title:t toc:t todo:t |:t
#+TITLES: EffectivePython
#+DATE: <2017-05-31 Wed>
#+AUTHORS: weiwu
#+EMAIL: victor.wuv@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.5.1 (Org mode 8.3.4)


* Pythonic Thinking

* Functions

* Classes and inheritance

* Metaclasses and atributes

* Concurrency and parallelism

* Built-in modules

* Collaboration

** Documenting
Write docstrings for every function, class, and module.

** Packages
#+BEGIN_EXAMPLE
--main.py
--mypackage
    |-- __init__.py
    |-- mypackage/models.py
    |-- mypackage/utils.py
#+END_EXAMPLE
#+BEGIN_SRC python
# main.py
from mypackage import utils
#+END_SRC

*** stable API
The value of __all__ is a list of every name to
export from the module as part of its public API.
#+BEGIN_SRC python
# utils.py
from . models import Projectile
all__ = [‘simulate_collision’]
def _dot_product(a, b):
# …
def simulate_collision(a, b):
# …
# __init__.py
all__ = []
from . models import *
all__ += models.__all__
from . utils import *
all__ += utils.__all__
# api_consumer.py
from mypackage import *
a = Projectile(1.5, 3)
b = Projectile(4, 1.7)
after_a, after_b = simulate_collision(a, b)
#+END_SRC
internal-only functions like mypackage.utils._dot_product will not be
available to the API consumer on mypackage because they weren’t present in all__. Being omitted from __all__ means they weren’t imported by the from mypackage import * statement.
* Production
** Test Everything with unittest
#+BEGIN_SRC python
# utils.py
def to_str(data):
if isinstance(data, str):
    return data
elif isinstance(data, bytes):
    return data.decode(‘utf-8’)
else:
    raise TypeError(‘Must supply str or bytes, ‘
‘found: %r’ % data)
#+END_SRC
#+BEGIN_SRC python
# utils_test.py
from unittest import TestCase, main
from utils import to_str
class UtilsTestCase(TestCase):
    def test_to_str_bytes(self):
        self.assertEqual(‘hello’, to_str(b’hello’))
    def test_to_str_str(self):
        self.assertEqual(‘hello’, to_str(‘hello’))
    def test_to_str_bad(self):
        self.assertRaises(TypeError, to_str, object())
if __name__ == ‘__main__’:
    main()
#+END_SRC
The TestCase class provides helper methods for making assertions in your tests, such as assertEqual for verifying equality, assertTrue for verifying Boolean expressions, and assertRaises for verifying that exceptions are raised when appropriate (see help(TestCase) for more). You can define your own helper methods in TestCase subclasses to make your tests more readable; just ensure that your method names don’t begin with the word test.
*** unittest.mock built-in module
[[http://nose.readthedocs.org][NoseTest]]
** Profile before optimizing
1. 如何查看python程序的运行效率：
The dynamic nature of Python causes surprising behaviors in its runtime performance.
Operations you might assume are slow are actually very fast (string manipulation,
generators). Language features you might assume are fast are actually very slow (attribute
access, function calls). The true source of slowdowns in a Python program can be obscure.
The best approach is to ignore your intuition and directly measure the performance of a
program before you try to optimize it. Python provides a built-in profiler for determining
which parts of a program are responsible for its execution time. This lets you focus your
optimization efforts on the biggest sources of trouble and ignore parts of the program that
don’t impact speed.
STEPS:
1). install snakeviz using pip from cmd.
#+BEGIN_SRC shell
pip install snakeviz
#+END_SRC

2). profile the test python file using below command.
#+BEGIN_SRC shell
$ python -m cProfile -o profile.stats test.py
# test.py
from random import randint
max_size = 10**4
data = [randint(0, max_size) for _ in range(max_size)]
test = lambda: insertion_sort(data)
#+END_SRC
3). check the efficiency result from profile.stats file.
#+BEGIN_SRC shell
$ snakeviz profile.stats
#+END_SRC
** Use tracemalloc to Understand Memory Usage and Leaks
